# -*- coding: utf-8 -*-

from odoo import fields, models, api, exceptions
from datetime import datetime

PROGRESS_INFO = [('draft', 'Draft'), ('generated', 'Generated')]
PAY_TYPE = [('allowance', 'Allowance'), ('deduction', 'Deduction')]
CURRENT_DATE = datetime.now().strftime("%Y-%m-%d")
CURRENT_TIME = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
INDIA_TIME = datetime.now().strftime("%d-%m-%Y %H:%M:%S")


# Payslip
class Payslip(models.Model):
    _name = "pay.slip"
    _inherit = "mail.thread"
    _rec_name = "person_id"

    date = fields.Date(string="Date", required=True, default=CURRENT_DATE)
    person_id = fields.Many2one(comodel_name="arc.person", string="Employee", readonly=True)
    month_id = fields.Many2one(comodel_name="month.attendance", string="Month", readonly=True)
    payslip_details = fields.One2many(comodel_name="payslip.detail", inverse_name="payslip_id")
    month_days = fields.Float(string="Total Days", readonly=True)
    schedule_days = fields.Float(string="Scheduled Days", readonly=True)
    lop_days = fields.Float(string="Lop Days", readonly=True)
    payslip_report = fields.Html(string="Payslip Report", readonly=True)
    writter = fields.Text(string="Writter", track_visibility='always')

    _sql_constraints = [('payslip_uniq', 'unique(person_id, month_id)', 'Payslip is already generated')]

    def check_items(self):
        hr_pay_id = self.env["hr.pay"].search([("person_id", "=", self.person_id.id)])

        if not hr_pay_id:
            raise exceptions.ValidationError("Error! Pay details is not configured")

        if self.month_id.progress != "closed":
            raise exceptions.ValidationError("Error! Monthly attendance is not closed")

    @api.multi
    def generate_payslip(self):
        self.check_items()
        self.payslip_details.unlink()

        pay = self.update_payslip_dict()

        hr_pay_id = self.env["hr.pay"].search([("person_id", "=", self.person_id.id)])
        work_id = self.env["work.sheet"].search([("person_id", "=", self.person_id.id),
                                                 ("month_id", "=", self.month_id.id)])

        recs = hr_pay_id.structure_id.detail_ids
        sorted(recs, key=lambda x: x.sequence)

        self.month_days = work_id.month_days
        self.schedule_days = work_id.schedule_days
        self.lop_days = work_id.lop_days

        for rec in recs:
            amount = 0
            if rec.is_need:
                if self.month_days:
                    amount = (pay[rec.rule_id.code.name] / work_id.month_days) * (work_id.schedule_days - work_id.lop_days)
                data = {"code": rec.rule_id.code.id,
                        "amount": amount,
                        "payslip_id": self.id,
                        "pay_order": rec.sequence,
                        "pay_type": rec.pay_type}
                self.env["payslip.detail"].create(data)

        writter = "Payslip is generated by {0}".format(self.env.user.name)
        self.write({"writter": writter})

    @api.multi
    def update_payslip_dict(self):
        hr_pay_id = self.env["hr.pay"].search([("person_id", "=", self.person_id.id)])
        recs = hr_pay_id.structure_id.detail_ids
        sorted(recs, key=lambda x: x.sequence)

        pay = {"BASIC": hr_pay_id.basic}

        for rec in recs:
            if rec.rule_id.rule_type == "fixed":
                pay[rec.rule_id.code.name] = rec.rule_id.fixed

            elif rec.rule_id.rule_type == "formula":
                pay[rec.rule_id.code.name] = eval(rec.rule_id.formula, pay)

            elif rec.rule_id.rule_type == "slab":
                for record in rec.rule_id.slab_ids:
                    if record.range_till >= eval(record.slab_input, pay) >= record.range_from:
                        if record.slab_type == "fixed":
                            pay[rec.rule_id.code.name] = record.fixed
                        elif record.slab_type == "formula":
                            pay[rec.rule_id.code.name] = eval(record.formula, pay)
                        else:
                            pay[rec.rule_id.code.name] = 0
                    else:
                        pay[rec.rule_id.code.name] = 0
        return pay


class PayslipDetail(models.Model):
    _name = "payslip.detail"

    code = fields.Many2one(comodel_name="salary.rule.code", string="Code", readonly=True)
    amount = fields.Float(string="Amount", readonly=True)
    pay_order = fields.Integer(string="Pay Order", readonly=True)
    pay_type = fields.Selection(PAY_TYPE, string='Pay Type', readonly=True)
    payslip_id = fields.Many2one(comodel_name="pay.slip", string="payslip")

    _sql_constraints = [('salary_details_uniq', 'unique(code, payslip_id)', 'Salary details should not duplicated')]

